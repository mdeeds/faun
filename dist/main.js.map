{"version":3,"file":"main.js","mappings":";;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,4BAA4B,OAAO;AACnC;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C,wDAAwD;AACxD;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;;;;;;ACrDa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,mBAAO,CAAC,GAAY;AACvC,qBAAqB,mBAAO,CAAC,GAAc;AAC3C,oBAAoB,mBAAO,CAAC,GAAa;AACzC,gBAAgB,mBAAO,CAAC,EAAS;AACjC,sBAAsB,mBAAO,CAAC,GAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,qCAAqC;AACtF;AACA;AACA;AACA;AACA;AACA,iDAAiD,uCAAuC;AACxF;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;AClDa;AACb;AACA,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ,EAAE,MAAM,EAAE,gBAAgB,EAAE,OAAO;AACvF;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ,EAAE,MAAM,EAAE,gBAAgB,EAAE,OAAO;AACvF;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,kBAAkB;AAClB;;;;;;;ACnDa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;;;;;;AC1Ba;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa;AACb;AACA;AACA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA,uDAAuD,mCAAmC;AAC1F;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,EAAE;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;ACrCa;AACb;AACA;AACA;AACA;AACA,eAAe,oCAAoC;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,0CAA0C,4BAA4B;AACtE,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,iBAAiB;AACvC,2BAA2B,mBAAO,CAAC,GAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,uBAAuB;AAC/E,sDAAsD,qBAAqB;AAC3E,uDAAuD,sBAAsB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gBAAgB;AACtD;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA,6CAA6C,EAAE;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;;;;;;AC9QA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://faun/./src/autoharp.js","webpack://faun/./src/index.js","webpack://faun/./src/midiHelper.js","webpack://faun/./src/octotonic.js","webpack://faun/./src/organ.js","webpack://faun/./src/touchCanvas.js","webpack://faun/external var \"THREE\"","webpack://faun/webpack/bootstrap","webpack://faun/webpack/before-startup","webpack://faun/webpack/startup","webpack://faun/webpack/after-startup"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AutoHarp = void 0;\nclass AutoHarp {\n    constructor(tc, organ) {\n        const allPipes = [];\n        const lineMap = new Map();\n        {\n            const stride = 8;\n            let x = 800;\n            let y = 88 * stride + 20;\n            for (let i = 0; i < 88; ++i) {\n                const l = tc.addLine(x, y, x + 200, y, (et) => {\n                    switch (et) {\n                        case 'on':\n                            organ.pluck(i);\n                            break;\n                        case 'off':\n                            organ.mute(i);\n                            break;\n                    }\n                });\n                lineMap.set(i, l);\n                allPipes.push(l);\n                y -= stride;\n            }\n        }\n        {\n            const stride = 120;\n            const radius = 90;\n            let noteMods = [2, 5, 1]; // D F C#\n            for (let j = 0; j < 3; ++j) {\n                let noteMod = noteMods[j];\n                for (let i = 0; i < 6; ++i) {\n                    let y = j * stride * (Math.sqrt(3.0) / 2.0) + radius;\n                    let x = i * stride + radius;\n                    if (j % 2 != 0) {\n                        x += stride / 2.0;\n                    }\n                    const pipes = [];\n                    for (let i = 0; i < 88; ++i) {\n                        if ((i + 21) % 12 == noteMod) { // Add 21 because that is A0.\n                            pipes.push(allPipes[i]);\n                        }\n                    }\n                    tc.addCircle(x, y, radius, (et) => { }, pipes);\n                    noteMod = (noteMod + 7) % 12;\n                }\n            }\n        }\n    }\n}\nexports.AutoHarp = AutoHarp;\n//# sourceMappingURL=autoharp.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst autoharp_1 = require(\"./autoharp\");\nconst midiHelper_1 = require(\"./midiHelper\");\nconst octotonic_1 = require(\"./octotonic\");\nconst organ_1 = require(\"./organ\");\nconst touchCanvas_1 = require(\"./touchCanvas\");\nconst audioButton = document.createElement('button');\naudioButton.textContent = 'Speakers';\ndocument.body.appendChild(audioButton);\naudioButton.addEventListener('click', () => __awaiter(void 0, void 0, void 0, function* () {\n    document.body.innerHTML = '';\n    const audioContext = new AudioContext();\n    const canvas = document.createElement('canvas');\n    canvas.classList.add('touchArea');\n    document.body.appendChild(canvas);\n    const tc = new touchCanvas_1.TouchCanvas(canvas);\n    const organ = new organ_1.Organ(audioContext);\n    {\n        const button = document.createElement('button');\n        button.textContent = 'Autoharp';\n        document.body.appendChild(button);\n        button.addEventListener('click', () => { new autoharp_1.AutoHarp(tc, organ); });\n    }\n    {\n        const button = document.createElement('button');\n        button.textContent = 'Octotonic';\n        document.body.appendChild(button);\n        button.addEventListener('click', () => { new octotonic_1.Octotonic(tc, organ); });\n    }\n}));\nconst midiButton = document.createElement('button');\nmidiButton.textContent = 'MIDI';\ndocument.body.appendChild(midiButton);\nmidiButton.addEventListener('click', () => __awaiter(void 0, void 0, void 0, function* () {\n    document.body.innerHTML = '';\n    const o = yield midiHelper_1.MIDIHelper.getDefaultOutput();\n    document.body.innerHTML = '';\n    const i = yield midiHelper_1.MIDIHelper.getDefaultInput();\n    document.body.innerHTML = '';\n}));\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MIDIHelper = void 0;\nclass MIDIHelper {\n    static getDefaultOutput() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!navigator.requestMIDIAccess)\n                throw new Error(\"Your browser does not support WebMIDI API\");\n            const access = yield navigator.requestMIDIAccess();\n            return new Promise((resolve, reject) => {\n                document.body.innerHTML = '';\n                for (const [name, o] of access.outputs.entries()) {\n                    const button = document.createElement('button');\n                    button.textContent = `${o.name} ${o.id} ${o.manufacturer} ${o.type}`;\n                    button.addEventListener('click', function () {\n                        resolve(o);\n                    }.bind(o));\n                    document.body.appendChild(button);\n                }\n            });\n        });\n    }\n    static getDefaultInput() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!navigator.requestMIDIAccess)\n                throw new Error(\"Your browser does not support WebMIDI API\");\n            const access = yield navigator.requestMIDIAccess();\n            return new Promise((resolve, reject) => {\n                document.body.innerHTML = '';\n                for (const [name, i] of access.inputs.entries()) {\n                    const button = document.createElement('button');\n                    button.textContent = `${i.name} ${i.id} ${i.manufacturer} ${i.type}`;\n                    button.addEventListener('click', function () {\n                        resolve(i);\n                    }.bind(i));\n                    document.body.appendChild(button);\n                }\n            });\n        });\n    }\n}\nexports.MIDIHelper = MIDIHelper;\n//# sourceMappingURL=midiHelper.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Octotonic = void 0;\nclass Octotonic {\n    constructor(tc, organ) {\n        let j = 0;\n        const stride = 95;\n        const radius = 50;\n        for (let i = 0; i < 48; ++i) {\n            const x = (Math.floor(i / 3) + 0.5 * j) * stride + radius;\n            const y = (4 - j) * stride * Math.sqrt(3) / 2;\n            tc.addCircle(x, y, radius, (et) => {\n                switch (et) {\n                    case 'on':\n                        organ.pluck(i + 30);\n                        break;\n                    case 'off':\n                        organ.mute(i + 30);\n                        break;\n                }\n            }, []);\n            j = (j + 1) % 3;\n        }\n    }\n}\nexports.Octotonic = Octotonic;\n//# sourceMappingURL=octotonic.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Organ = void 0;\nclass Organ {\n    constructor(audioCtx) {\n        this.audioCtx = audioCtx;\n        this.pipes = [];\n        const gainOut = new GainNode(audioCtx, { gain: 0.2 });\n        // A0 = 21 = 27.5 Hz\n        for (let i = 0; i < 88; ++i) {\n            const note = 21 + i;\n            const freq = 27.5 * Math.pow(2.0, i / 12);\n            const osc = new OscillatorNode(audioCtx, { frequency: freq, type: 'triangle' });\n            osc.start();\n            const pipe = new GainNode(audioCtx, { gain: 0 });\n            osc.connect(pipe);\n            pipe.connect(gainOut);\n            this.pipes.push(pipe);\n        }\n        gainOut.connect(audioCtx.destination);\n    }\n    pluck(i) {\n        console.log(`Pluck: ${i}`);\n        const pipe = this.pipes[i];\n        const fullTime = this.audioCtx.currentTime + 0.05;\n        pipe.gain.linearRampToValueAtTime(1.0, fullTime);\n        pipe.gain.setTargetAtTime(0.0, fullTime, 0.5);\n    }\n    mute(i) {\n        const pipe = this.pipes[i];\n        const current = pipe.gain.value;\n        const nowTime = this.audioCtx.currentTime;\n        pipe.gain.cancelScheduledValues(nowTime);\n        pipe.gain.setTargetAtTime(0.0, nowTime, 0.1);\n    }\n}\nexports.Organ = Organ;\n//# sourceMappingURL=organ.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TouchCanvas = exports.TouchLine = void 0;\nconst THREE = __importStar(require(\"three\"));\nclass TouchLine {\n    constructor(a, b) {\n        this.a = a;\n        this.b = b;\n        this.dir = new THREE.Vector2();\n        this.enableCount = 0;\n        this.tmp = new THREE.Vector2();\n        this.dir.copy(b);\n        this.dir.sub(a);\n        this.length = this.dir.length();\n        this.dir.normalize();\n    }\n    isEnabled() {\n        return this.enableCount > 0;\n    }\n    decrement() {\n        this.enableCount--;\n    }\n    increment() {\n        this.enableCount++;\n    }\n    render(ctx) {\n        if (this.isEnabled()) {\n            ctx.strokeStyle = '#000';\n        }\n        else {\n            ctx.strokeStyle = '#0004';\n        }\n        ctx.lineWidth = 4;\n        ctx.beginPath();\n        ctx.moveTo(this.a.x, this.a.y);\n        ctx.lineTo(this.b.x, this.b.y);\n        ctx.stroke();\n    }\n    // Returns a positive number if left, negative number if right, zero if on the line\n    side(p0) {\n        this.tmp.copy(p0);\n        this.tmp.sub(this.a);\n        const len = this.tmp.dot(this.dir);\n        if (len < 0 || len > this.length) {\n            // Beyond the extent \n            return 0.0;\n        }\n        else {\n            return this.dir.cross(this.tmp);\n        }\n    }\n    near(p0) {\n        this.tmp.copy(p0);\n        this.tmp.sub(this.a);\n        const len = this.tmp.dot(this.dir);\n        if (len < 0 || len > this.length) {\n            // Beyond the extent \n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n    // Returns true if moving from p0 to p1 crosses the line.\n    crosses(p0, p1) {\n        if (!this.near(p0) || !this.near(p1)) {\n            // We don't cross the line if either p0 or p1 are beyond the end of the line.\n            return false;\n        }\n        const side0 = this.side(p0);\n        const side1 = this.side(p1);\n        if (side0 < 0 && side1 >= 0)\n            return true;\n        if (side0 >= 0 && side1 < 0)\n            return true;\n        return false;\n    }\n}\nexports.TouchLine = TouchLine;\nclass TouchCircle {\n    constructor(center, radius, enableSet) {\n        this.center = center;\n        this.radius = radius;\n        this.enableSet = enableSet;\n        this.tmp = new THREE.Vector2();\n        this.isActive = false;\n    }\n    inside(p0) {\n        this.tmp.copy(p0);\n        this.tmp.sub(this.center);\n        return this.tmp.length() < this.radius;\n    }\n    setActive(active) {\n        if (active == this.isActive)\n            return;\n        this.isActive = active;\n        if (active) {\n            for (const l of this.enableSet) {\n                l.increment();\n            }\n        }\n        else {\n            for (const l of this.enableSet) {\n                l.decrement();\n            }\n        }\n    }\n    active() { return this.isActive; }\n    render(ctx) {\n        if (this.isActive) {\n            ctx.fillStyle = '#ff08';\n        }\n        else {\n            ctx.fillStyle = '#0004';\n        }\n        ctx.beginPath();\n        ctx.arc(this.center.x, this.center.y, this.radius, -Math.PI, Math.PI);\n        ctx.fill();\n    }\n}\nclass TouchCanvas {\n    constructor(canvas) {\n        this.canvas = canvas;\n        this.currentPositions = new Map();\n        this.circles = [];\n        this.circleCallbacks = [];\n        this.lines = [];\n        this.lineCallbacks = [];\n        this.newPosition = new THREE.Vector2();\n        this.wasActive = new Set();\n        this.nowActive = new Set();\n        this.latestIds = new Set();\n        this.ctx = canvas.getContext('2d');\n        canvas.addEventListener('touchstart', (ev) => { this.handleStart(ev); });\n        canvas.addEventListener('touchend', (ev) => { this.handleEnd(ev); });\n        canvas.addEventListener('touchmove', (ev) => { this.handleMove(ev); });\n        this.render();\n    }\n    addCircle(x, y, r, h, enableSet) {\n        this.circles.push(new TouchCircle(new THREE.Vector2(x, y), r, enableSet));\n        this.circleCallbacks.push(h);\n    }\n    addLine(x0, y0, x1, y1, h) {\n        const line = new TouchLine(new THREE.Vector2(x0, y0), new THREE.Vector2(x1, y1));\n        this.lines.push(line);\n        this.lineCallbacks.push(h);\n        return line;\n    }\n    render() {\n        if (this.canvas.width != this.canvas.clientWidth) {\n            this.canvas.width = this.canvas.clientWidth;\n            this.canvas.height = this.canvas.clientHeight;\n        }\n        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        this.ctx.fillStyle = '#deb';\n        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        for (const c of this.circles) {\n            c.render(this.ctx);\n        }\n        for (const l of this.lines) {\n            l.render(this.ctx);\n        }\n        this.ctx.fillStyle = '#f00';\n        for (const [id, p] of this.currentPositions) {\n            this.ctx.beginPath();\n            this.ctx.arc(p.x, p.y, 20, -Math.PI, Math.PI);\n            this.ctx.fill();\n        }\n        requestAnimationFrame(() => { this.render(); });\n    }\n    updateTouchPositions(touches) {\n        this.wasActive.clear();\n        this.nowActive.clear();\n        for (let i = 0; i < this.circles.length; ++i) {\n            const circle = this.circles[i];\n            if (circle.active()) {\n                this.wasActive.add(i);\n            }\n        }\n        for (const touch of touches) {\n            let touchPosition = null;\n            if (this.currentPositions.has(touch.identifier)) {\n                touchPosition = this.currentPositions.get(touch.identifier);\n                this.newPosition.set(touch.clientX, touch.clientY);\n                for (let i = 0; i < this.lines.length; ++i) {\n                    const l = this.lines[i];\n                    if (l.isEnabled() && l.crosses(touchPosition, this.newPosition)) {\n                        console.log(`Cross ${i}`);\n                        this.lineCallbacks[i]('on');\n                    }\n                }\n                touchPosition.set(touch.clientX, touch.clientY);\n            }\n            else {\n                touchPosition = new THREE.Vector2(touch.clientX, touch.clientY);\n                this.currentPositions.set(touch.identifier, touchPosition);\n            }\n            for (let i = 0; i < this.circles.length; ++i) {\n                const circle = this.circles[i];\n                if (circle.inside(touchPosition)) {\n                    this.nowActive.add(i);\n                }\n            }\n        }\n        for (const i of this.nowActive) {\n            const circle = this.circles[i];\n            if (!this.wasActive.has(i)) {\n                circle.setActive(true);\n                this.circleCallbacks[i]('on');\n            }\n        }\n        for (const i of this.wasActive) {\n            const circle = this.circles[i];\n            if (!this.nowActive.has(i)) {\n                circle.setActive(false);\n                this.circleCallbacks[i]('off');\n            }\n        }\n    }\n    handleStart(ev) {\n        ev.preventDefault();\n        this.updateTouchPositions(ev.touches);\n    }\n    handleEnd(ev) {\n        ev.preventDefault();\n        this.latestIds.clear();\n        for (const touch of ev.touches) {\n            this.latestIds.add(touch.identifier);\n        }\n        const toRemove = [];\n        for (const [id, p] of this.currentPositions) {\n            if (!this.latestIds.has(id)) {\n                toRemove.push(id);\n                // Touch ended.\n            }\n        }\n        for (const id of toRemove) {\n            this.currentPositions.delete(id);\n        }\n        this.updateTouchPositions(ev.touches);\n    }\n    handleMove(ev) {\n        ev.preventDefault();\n        this.updateTouchPositions(ev.touches);\n    }\n}\nexports.TouchCanvas = TouchCanvas;\n//# sourceMappingURL=touchCanvas.js.map","module.exports = THREE;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(138);\n",""],"names":[],"sourceRoot":""}